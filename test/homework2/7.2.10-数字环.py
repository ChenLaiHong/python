"""
【问题描述】设计一个程序，使其将由1到N（N为偶数，且N <= 20）的N个正整数分别放置在由N个节点组成的环的各个节点上，
其中1必须放在第一个节点上，并使任意两个相邻的节点上的数字之和为质数。要求最后一个数和开头第一个数（即1）之和也为质数。
下图是当N为6时的一个例。当N为6时的输出样例如下：
1 4 3 2 5 6
1 6 5 2 3 4
【输入形式】程序从标准输入上读入一个偶数。
【输出形式】在标准输出上打印所有符合要求的排列方法。
输出有若干行，每一行都是符合题意的一种排列方法，所有数字从1所在位置开始，按顺时针方向依次输出，各个数字之间以空格分隔。
各行上的排列方式不重复。
注意：输出各行遵循小数优先原则, 在各种排列方式中，较小的数尽量靠前输出。如果将每行上的输出看成一个数字，则所有输出构成升序数列。
具体格式见输出样例。
【样例输入】
8
【样例输出】
1 2 3 8 5 6 7 4
1 2 5 8 3 4 7 6
1 4 7 6 5 8 3 2
1 6 7 4 3 8 5 2
【样例说明】输入整数8，要求将1、2、......、8排成环且相邻两数之和为素数。
合法的排列方法共有4种，由运行结果可见，第2位上可能的数字只有2、4和6。且先输出2开头的所有合法排列，再输出4开头的所有合法排列，
最后输出6开头的所有合法排列，余下部分同样遵循此原则。
"""
# 素数判断
def sushu(num):
    # 质数大于 1
    if num > 1:
        # 查看因子
        for i in range(2, num):
            if (num % i) == 0:
                return False
        else:
            return True
    # 如果输入的数字小于或等于 1，不是质数
    else:
        return False
def change(result, temp):
    for n in temp:
        if sushu(result[len(result)-1] + n):
            result.append(n)
            temp.remove(n)
        return result, temp
# 相邻之和判断
result = [1]
number = int(input())
temp = []
n = 0
m = 2
while m <= number:
    temp.append(m)
    m += 1
while n < number:
    print(change(result, temp))
    n += 1
print(result, temp)





