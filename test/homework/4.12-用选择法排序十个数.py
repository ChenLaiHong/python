"""
【问题描述】
用选择法对10个整数进行从小到大的排序。
这里采用的选择法的思路是进行9轮比较和交换：
（1）遍历10个数，选出最小的数，该数和10个数中首位置的数进行交换；
（2）遍历末尾的9个数，选出最小的数，该数和末尾9个数中首位置的数的进行交换；
（3）遍历末尾的8个数，选出最小的数，交换至末尾8个数中首位置，......，依次类推，直至排序完成。
【输入形式】
输入十个整数
【输出形式】
输出9行。
前8行是9轮比较和交换后的整数序列。
第9行是排序后的十个整数。
数之间用空格隔开。
【样例输入】
4 5 3 6 7 2 1 8 10 9
【样例输出】
1 5 3 6 7 2 4 8 10 9 
1 2 3 6 7 5 4 8 10 9 
1 2 3 6 7 5 4 8 10 9 
1 2 3 4 7 5 6 8 10 9 
1 2 3 4 5 7 6 8 10 9 
1 2 3 4 5 6 7 8 10 9 
1 2 3 4 5 6 7 8 10 9 
1 2 3 4 5 6 7 8 10 9 
1 2 3 4 5 6 7 8 9 10 
"""
number = input().split()
for n in range(number.__len__()):
    number[n] = int(number[n])

# 寻找列表中最小的值
def findMin(numberList):
    temp = sorted(numberList)
    return temp[0]

# 设置两个相同的列表，前面为协助列表
numberTemp = number.copy()
# 循环最原始列表
for t in range(number.__len__()-1):
    # 从协助列表中找到最小值，后再在原始列表中找到对应值的索引，赋值给临时变量
    temp = number.index(findMin(numberTemp))
    # 在原始列表中进行交换，把最小值与前面前面交换，第一次时将最小值1交换到原始列表下标为0的位置
    number[t], number[temp] = number[temp], number[t]
    # 交换完一次后将原始列表输出，输出的结果是已经进行过交换的结果
    for n in range(number.__len__()):
        print(number[n], end=" ")
    print()
    # 修改协助列表，因为原始列表已经进行交换了一次，那么协助列表就不能跟原始列表相同了，
    # 如果相同那么最小值就一直不变了，所以协助列表取原始列表去掉第一个之后的列表，再继续....
    numberTemp = number[t+1: number.__len__()]
